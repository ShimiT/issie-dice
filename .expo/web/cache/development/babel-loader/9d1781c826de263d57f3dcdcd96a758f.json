{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _excluded = [\"onContextCreate\", \"onContextRestored\", \"onContextLost\", \"webglContextAttributes\", \"msaaSamples\", \"nativeRef_EXPERIMENTAL\", \"ref\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Canvas from \"./Canvas\";\nfunction getImageForAsset(asset) {\n  if (asset != null && typeof asset === 'object' && asset !== null && asset.downloadAsync) {\n    var dataURI = asset.localUri || asset.uri || '';\n    var image = new Image();\n    image.src = dataURI;\n    return image;\n  }\n  return asset;\n}\nfunction isOffscreenCanvas(element) {\n  return element && typeof element.convertToBlob === 'function';\n}\nfunction asExpoContext(gl) {\n  gl.endFrameEXP = function glEndFrameEXP() {};\n  if (!gl['_expo_texImage2D']) {\n    gl['_expo_texImage2D'] = gl.texImage2D;\n    gl.texImage2D = function () {\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n      var nextProps = [].concat(props);\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texImage2D'].apply(gl, _toConsumableArray(nextProps));\n    };\n  }\n  if (!gl['_expo_texSubImage2D']) {\n    gl['_expo_texSubImage2D'] = gl.texSubImage2D;\n    gl.texSubImage2D = function () {\n      for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        props[_key2] = arguments[_key2];\n      }\n      var nextProps = [].concat(props);\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texSubImage2D'].apply(gl, _toConsumableArray(nextProps));\n    };\n  }\n  return gl;\n}\nfunction ensureContext(canvas, contextAttributes) {\n  if (!canvas) {\n    throw new CodedError('ERR_GL_INVALID', 'Attempting to use the GL context before it has been created.');\n  }\n  var isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\n  var context = !isIOS && canvas.getContext('webgl2', contextAttributes) || canvas.getContext('webgl', contextAttributes) || canvas.getContext('webgl-experimental', contextAttributes) || canvas.getContext('experimental-webgl', contextAttributes);\n  invariant(context, 'Browser does not support WebGL');\n  return asExpoContext(context);\n}\nfunction getBlobFromWebGLRenderingContext(_x) {\n  return _getBlobFromWebGLRenderingContext.apply(this, arguments);\n}\nfunction _getBlobFromWebGLRenderingContext() {\n  _getBlobFromWebGLRenderingContext = _asyncToGenerator(function* (gl) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    invariant(gl, 'getBlobFromWebGLRenderingContext(): WebGL Rendering Context is not defined');\n    var canvas = gl.canvas;\n    var blob = null;\n    if (typeof canvas.msToBlob === 'function') {\n      blob = yield canvas.msToBlob();\n    } else if (isOffscreenCanvas(canvas)) {\n      blob = yield canvas.convertToBlob({\n        quality: options.compress,\n        type: options.format\n      });\n    } else {\n      blob = yield new Promise(function (resolve) {\n        canvas.toBlob(function (blob) {\n          return resolve(blob);\n        }, options.format, options.compress);\n      });\n    }\n    return {\n      blob: blob,\n      width: canvas.width,\n      height: canvas.height\n    };\n  });\n  return _getBlobFromWebGLRenderingContext.apply(this, arguments);\n}\nexport var GLView = function (_React$Component) {\n  _inherits(GLView, _React$Component);\n  var _super = _createSuper(GLView);\n  function GLView() {\n    var _this;\n    _classCallCheck(this, GLView);\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.onContextLost = function (event) {\n      if (event && event.preventDefault) {\n        event.preventDefault();\n      }\n      _this.gl = undefined;\n      if (typeof _this.props.onContextLost === 'function') {\n        _this.props.onContextLost();\n      }\n    };\n    _this.onContextRestored = function () {\n      _this.gl = undefined;\n      if (_this.getGLContext() == null) {\n        throw new CodedError('ERR_GL_INVALID', 'Failed to restore GL context.');\n      }\n    };\n    _this.setCanvasRef = function (canvas) {\n      _this.canvas = canvas;\n      if (typeof _this.props.nativeRef_EXPERIMENTAL === 'function') {\n        _this.props.nativeRef_EXPERIMENTAL(canvas);\n      }\n      if (_this.canvas) {\n        _this.canvas.addEventListener('webglcontextlost', _this.onContextLost);\n        _this.canvas.addEventListener('webglcontextrestored', _this.onContextRestored);\n        _this.getGLContext();\n      }\n    };\n    return _this;\n  }\n  _createClass(GLView, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.gl) {\n        var loseContextExt = this.gl.getExtension('WEBGL_lose_context');\n        if (loseContextExt) {\n          loseContextExt.loseContext();\n        }\n        this.gl = undefined;\n      }\n      if (this.canvas) {\n        this.canvas.removeEventListener('webglcontextlost', this.onContextLost);\n        this.canvas.removeEventListener('webglcontextrestored', this.onContextRestored);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        onContextCreate = _this$props.onContextCreate,\n        onContextRestored = _this$props.onContextRestored,\n        onContextLost = _this$props.onContextLost,\n        webglContextAttributes = _this$props.webglContextAttributes,\n        msaaSamples = _this$props.msaaSamples,\n        nativeRef_EXPERIMENTAL = _this$props.nativeRef_EXPERIMENTAL,\n        ref = _this$props.ref,\n        domProps = _objectWithoutProperties(_this$props, _excluded);\n      return React.createElement(Canvas, _objectSpread(_objectSpread({}, domProps), {}, {\n        canvasRef: this.setCanvasRef\n      }));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var webglContextAttributes = this.props.webglContextAttributes;\n      if (this.canvas && webglContextAttributes !== prevProps.webglContextAttributes) {\n        this.onContextLost(null);\n        this.onContextRestored();\n      }\n    }\n  }, {\n    key: \"getGLContextOrReject\",\n    value: function getGLContextOrReject() {\n      var gl = this.getGLContext();\n      if (!gl) {\n        throw new CodedError('ERR_GL_INVALID', 'Attempting to use the GL context before it has been created.');\n      }\n      return gl;\n    }\n  }, {\n    key: \"getGLContext\",\n    value: function getGLContext() {\n      if (this.gl) return this.gl;\n      if (this.canvas) {\n        this.gl = ensureContext(this.canvas, this.props.webglContextAttributes);\n        if (typeof this.props.onContextCreate === 'function') {\n          this.props.onContextCreate(this.gl);\n        }\n        return this.gl;\n      }\n      return null;\n    }\n  }, {\n    key: \"takeSnapshotAsync\",\n    value: function () {\n      var _takeSnapshotAsync = _asyncToGenerator(function* () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!GLView.takeSnapshotAsync) {\n          throw new UnavailabilityError('expo-gl', 'takeSnapshotAsync');\n        }\n        var gl = this.getGLContextOrReject();\n        return yield GLView.takeSnapshotAsync(gl, options);\n      });\n      function takeSnapshotAsync() {\n        return _takeSnapshotAsync.apply(this, arguments);\n      }\n      return takeSnapshotAsync;\n    }()\n  }, {\n    key: \"startARSessionAsync\",\n    value: function () {\n      var _startARSessionAsync = _asyncToGenerator(function* () {\n        throw new UnavailabilityError('GLView', 'startARSessionAsync');\n      });\n      function startARSessionAsync() {\n        return _startARSessionAsync.apply(this, arguments);\n      }\n      return startARSessionAsync;\n    }()\n  }, {\n    key: \"createCameraTextureAsync\",\n    value: function () {\n      var _createCameraTextureAsync = _asyncToGenerator(function* () {\n        throw new UnavailabilityError('GLView', 'createCameraTextureAsync');\n      });\n      function createCameraTextureAsync() {\n        return _createCameraTextureAsync.apply(this, arguments);\n      }\n      return createCameraTextureAsync;\n    }()\n  }, {\n    key: \"destroyObjectAsync\",\n    value: function () {\n      var _destroyObjectAsync = _asyncToGenerator(function* (glObject) {\n        throw new UnavailabilityError('GLView', 'destroyObjectAsync');\n      });\n      function destroyObjectAsync(_x2) {\n        return _destroyObjectAsync.apply(this, arguments);\n      }\n      return destroyObjectAsync;\n    }()\n  }], [{\n    key: \"createContextAsync\",\n    value: function () {\n      var _createContextAsync = _asyncToGenerator(function* () {\n        if (!Platform.isDOMAvailable) {\n          return null;\n        }\n        var canvas = document.createElement('canvas');\n        var _Dimensions$get = Dimensions.get('window'),\n          width = _Dimensions$get.width,\n          height = _Dimensions$get.height,\n          scale = _Dimensions$get.scale;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        return ensureContext(canvas);\n      });\n      function createContextAsync() {\n        return _createContextAsync.apply(this, arguments);\n      }\n      return createContextAsync;\n    }()\n  }, {\n    key: \"destroyContextAsync\",\n    value: function () {\n      var _destroyContextAsync = _asyncToGenerator(function* (exgl) {\n        return true;\n      });\n      function destroyContextAsync(_x3) {\n        return _destroyContextAsync.apply(this, arguments);\n      }\n      return destroyContextAsync;\n    }()\n  }, {\n    key: \"takeSnapshotAsync\",\n    value: function () {\n      var _takeSnapshotAsync2 = _asyncToGenerator(function* (gl) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _yield$getBlobFromWeb = yield getBlobFromWebGLRenderingContext(gl, options),\n          blob = _yield$getBlobFromWeb.blob,\n          width = _yield$getBlobFromWeb.width,\n          height = _yield$getBlobFromWeb.height;\n        if (!blob) {\n          throw new CodedError('ERR_GL_SNAPSHOT', 'Failed to save the GL context');\n        }\n        return {\n          uri: blob,\n          localUri: '',\n          width: width,\n          height: height\n        };\n      });\n      function takeSnapshotAsync(_x4) {\n        return _takeSnapshotAsync2.apply(this, arguments);\n      }\n      return takeSnapshotAsync;\n    }()\n  }]);\n  return GLView;\n}(React.Component);","map":{"version":3,"sources":["../src/GLView.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport { Dimensions } from 'react-native';\n\nimport Canvas from './Canvas';\nimport { WebGLObject } from './GLView';\nimport {\n  GLViewProps,\n  ExpoWebGLRenderingContext,\n  GLSnapshot,\n  SnapshotOptions,\n  ComponentOrHandle,\n} from './GLView.types';\n\nfunction getImageForAsset(asset: {\n  downloadAsync: () => Promise<any>;\n  uri?: string;\n  localUri?: string;\n}): HTMLImageElement | any {\n  if (asset != null && typeof asset === 'object' && asset !== null && asset.downloadAsync) {\n    const dataURI = asset.localUri || asset.uri || '';\n    const image = new Image();\n    image.src = dataURI;\n    return image;\n  }\n  return asset;\n}\n\nfunction isOffscreenCanvas(element: any): element is OffscreenCanvas {\n  return element && typeof element.convertToBlob === 'function';\n}\n\nfunction asExpoContext(gl: ExpoWebGLRenderingContext): WebGLRenderingContext {\n  gl.endFrameEXP = function glEndFrameEXP(): void {};\n\n  if (!gl['_expo_texImage2D']) {\n    gl['_expo_texImage2D'] = gl.texImage2D;\n    gl.texImage2D = (...props: any[]): any => {\n      const nextProps = [...props];\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texImage2D'](...nextProps);\n    };\n  }\n\n  if (!gl['_expo_texSubImage2D']) {\n    gl['_expo_texSubImage2D'] = gl.texSubImage2D;\n    gl.texSubImage2D = (...props: any[]): any => {\n      const nextProps = [...props];\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texSubImage2D'](...nextProps);\n    };\n  }\n\n  return gl;\n}\n\nfunction ensureContext(\n  canvas?: HTMLCanvasElement,\n  contextAttributes?: WebGLContextAttributes\n): WebGLRenderingContext {\n  if (!canvas) {\n    throw new CodedError(\n      'ERR_GL_INVALID',\n      'Attempting to use the GL context before it has been created.'\n    );\n  }\n\n  // Apple disables WebGL 2.0 and doesn't provide any way to detect if it's disabled.\n  const isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\n\n  const context =\n    (!isIOS && canvas.getContext('webgl2', contextAttributes)) ||\n    canvas.getContext('webgl', contextAttributes) ||\n    canvas.getContext('webgl-experimental', contextAttributes) ||\n    canvas.getContext('experimental-webgl', contextAttributes);\n  invariant(context, 'Browser does not support WebGL');\n  return asExpoContext(context as ExpoWebGLRenderingContext);\n}\n\n// @needsAudit @docsMissing\nexport type GLViewWebProps = GLViewProps & {\n  onContextCreate: (gl: WebGLRenderingContext) => void;\n  onContextRestored?: (gl?: WebGLRenderingContext) => void;\n  onContextLost?: () => void;\n  webglContextAttributes?: WebGLContextAttributes;\n  // type overwrite\n  nativeRef_EXPERIMENTAL?(callback: ComponentOrHandle | HTMLCanvasElement | null);\n};\n\nasync function getBlobFromWebGLRenderingContext(\n  gl: WebGLRenderingContext,\n  options: SnapshotOptions = {}\n): Promise<{ width: number; height: number; blob: Blob | null }> {\n  invariant(gl, 'getBlobFromWebGLRenderingContext(): WebGL Rendering Context is not defined');\n\n  const { canvas } = gl;\n\n  let blob: Blob | null = null;\n\n  if (typeof (canvas as any).msToBlob === 'function') {\n    // @ts-ignore: polyfill: https://stackoverflow.com/a/29815058/4047926\n    blob = await canvas.msToBlob();\n  } else if (isOffscreenCanvas(canvas)) {\n    blob = await canvas.convertToBlob({ quality: options.compress, type: options.format });\n  } else {\n    blob = await new Promise((resolve) => {\n      canvas.toBlob((blob: Blob | null) => resolve(blob), options.format, options.compress);\n    });\n  }\n\n  return {\n    blob,\n    width: canvas.width,\n    height: canvas.height,\n  };\n}\n\nexport class GLView extends React.Component<GLViewWebProps> {\n  canvas?: HTMLCanvasElement;\n\n  gl?: WebGLRenderingContext;\n\n  static async createContextAsync(): Promise<WebGLRenderingContext | null> {\n    if (!Platform.isDOMAvailable) {\n      return null;\n    }\n    const canvas = document.createElement('canvas');\n    const { width, height, scale } = Dimensions.get('window');\n    canvas.width = width * scale;\n    canvas.height = height * scale;\n    return ensureContext(canvas);\n  }\n\n  static async destroyContextAsync(exgl?: WebGLRenderingContext | number): Promise<boolean> {\n    // Do nothing\n    return true;\n  }\n\n  static async takeSnapshotAsync(\n    gl: WebGLRenderingContext,\n    options: SnapshotOptions = {}\n  ): Promise<GLSnapshot> {\n    const { blob, width, height } = await getBlobFromWebGLRenderingContext(gl, options);\n\n    if (!blob) {\n      throw new CodedError('ERR_GL_SNAPSHOT', 'Failed to save the GL context');\n    }\n\n    return {\n      uri: blob,\n      localUri: '',\n      width,\n      height,\n    };\n  }\n\n  componentWillUnmount() {\n    if (this.gl) {\n      const loseContextExt = this.gl.getExtension('WEBGL_lose_context');\n      if (loseContextExt) {\n        loseContextExt.loseContext();\n      }\n      this.gl = undefined;\n    }\n    if (this.canvas) {\n      this.canvas.removeEventListener('webglcontextlost', this.onContextLost);\n      this.canvas.removeEventListener('webglcontextrestored', this.onContextRestored);\n    }\n  }\n\n  render() {\n    const {\n      onContextCreate,\n      onContextRestored,\n      onContextLost,\n      webglContextAttributes,\n      msaaSamples,\n      nativeRef_EXPERIMENTAL,\n      // @ts-ignore: ref does not exist\n      ref,\n      ...domProps\n    } = this.props;\n\n    return <Canvas {...domProps} canvasRef={this.setCanvasRef} />;\n  }\n\n  componentDidUpdate(prevProps) {\n    const { webglContextAttributes } = this.props;\n    if (this.canvas && webglContextAttributes !== prevProps.webglContextAttributes) {\n      this.onContextLost(null);\n      this.onContextRestored();\n    }\n  }\n\n  private getGLContextOrReject(): WebGLRenderingContext {\n    const gl = this.getGLContext();\n    if (!gl) {\n      throw new CodedError(\n        'ERR_GL_INVALID',\n        'Attempting to use the GL context before it has been created.'\n      );\n    }\n    return gl;\n  }\n\n  private onContextLost = (event: Event | null): void => {\n    if (event && event.preventDefault) {\n      event.preventDefault();\n    }\n    this.gl = undefined;\n\n    if (typeof this.props.onContextLost === 'function') {\n      this.props.onContextLost();\n    }\n  };\n\n  private onContextRestored = (): void => {\n    this.gl = undefined;\n    if (this.getGLContext() == null) {\n      throw new CodedError('ERR_GL_INVALID', 'Failed to restore GL context.');\n    }\n  };\n\n  private getGLContext(): WebGLRenderingContext | null {\n    if (this.gl) return this.gl;\n\n    if (this.canvas) {\n      this.gl = ensureContext(this.canvas, this.props.webglContextAttributes);\n      if (typeof this.props.onContextCreate === 'function') {\n        this.props.onContextCreate(this.gl);\n      }\n      return this.gl;\n    }\n    return null;\n  }\n\n  private setCanvasRef = (canvas: HTMLCanvasElement): void => {\n    this.canvas = canvas;\n\n    if (typeof this.props.nativeRef_EXPERIMENTAL === 'function') {\n      this.props.nativeRef_EXPERIMENTAL(canvas);\n    }\n\n    if (this.canvas) {\n      this.canvas.addEventListener('webglcontextlost', this.onContextLost);\n      this.canvas.addEventListener('webglcontextrestored', this.onContextRestored);\n\n      this.getGLContext();\n    }\n  };\n\n  public async takeSnapshotAsync(options: SnapshotOptions = {}): Promise<GLSnapshot> {\n    if (!GLView.takeSnapshotAsync) {\n      throw new UnavailabilityError('expo-gl', 'takeSnapshotAsync');\n    }\n\n    const gl = this.getGLContextOrReject();\n    return await GLView.takeSnapshotAsync(gl, options);\n  }\n\n  public async startARSessionAsync(): Promise<void> {\n    throw new UnavailabilityError('GLView', 'startARSessionAsync');\n  }\n\n  public async createCameraTextureAsync(): Promise<void> {\n    throw new UnavailabilityError('GLView', 'createCameraTextureAsync');\n  }\n\n  public async destroyObjectAsync(glObject: WebGLObject): Promise<void> {\n    throw new UnavailabilityError('GLView', 'destroyObjectAsync');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}