{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport THREE from \"./Three\";\nimport loadAsync from \"./loadAsync\";\nimport parseAssetCallback from \"./loaders/parseAssetCallback\";\nvar CubeTexture = function (_THREE$CubeTexture) {\n  _inherits(CubeTexture, _THREE$CubeTexture);\n  var _super = _createSuper(CubeTexture);\n  function CubeTexture() {\n    var _this;\n    _classCallCheck(this, CubeTexture);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.loadAsync = function () {\n      var _ref = _asyncToGenerator(function* (options) {\n        var nextDirections = options.directions || CubeTexture.format.coord_s;\n        for (var direction of nextDirections) {\n          var asset = yield parseAssetCallback(direction, options.assetForDirection);\n          var texture = yield loadAsync(asset);\n          _this.images.push(texture);\n        }\n        _this.needsUpdate = true;\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    return _this;\n  }\n  return _createClass(CubeTexture);\n}(THREE.CubeTexture);\nCubeTexture.format = {\n  direct_s: ['lf', 'rt', 'up', 'dn', 'ft', 'bk'],\n  coord_s: ['px', 'nx', 'py', 'ny', 'pz', 'nz'],\n  coord_m: ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg']\n};\nexport { CubeTexture as default };","map":{"version":3,"sources":["../src/CubeTexture.ts"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,KAAK;AACZ,OAAO,SAAS;AAChB,OAAO,kBAAkB;AAAqC,IAKzC,WAAY;EAAA;EAAA;EAAA;IAAA;IAAA;IAAA;MAAA;IAAA;IAAA;IAAA,MAM/B,SAAS;MAAA,6BAAG,WAAO,OAGlB,EAAI;QACH,IAAM,cAAc,GAAG,OAAO,CAAC,UAAU,IAAI,WAAW,CAAC,MAAM,CAAC,OAAO;QAEvE,KAAK,IAAI,SAAS,IAAI,cAAc,EAAE;UACpC,IAAM,KAAK,SAAS,kBAAkB,CACpC,SAAS,EACT,OAAO,CAAC,iBAAiB,CAC1B;UACD,IAAM,OAAO,SAAS,SAAS,CAAC,KAAK,CAAC;UACtC,MAAK,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;QAC1B;QACD,MAAK,WAAW,GAAG,IAAI;MACzB,CAAC;MAAA;QAAA;MAAA;IAAA;IAAA;EAAA;EAAA;AAAA,EArBsC,KAAK,CAAC,WAAW;AAArC,WAAY,CACxB,MAAM,GAAG;EACd,QAAQ,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;EAC9C,OAAO,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;EAC7C,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;CACzD;AAAA,SALkB,WAAY","sourcesContent":["import THREE from './Three';\nimport loadAsync from './loadAsync';\nimport parseAssetCallback from './loaders/parseAssetCallback';\n\ntype AnyFunction = (...args: any[]) => any;\ntype AnyObject = { [key: string]: any };\ntype ObjectOrFunction = AnyObject | AnyFunction;\nexport default class CubeTexture extends THREE.CubeTexture {\n  static format = {\n    direct_s: ['lf', 'rt', 'up', 'dn', 'ft', 'bk'],\n    coord_s: ['px', 'nx', 'py', 'ny', 'pz', 'nz'],\n    coord_m: ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'],\n  };\n  loadAsync = async (options: {\n    assetForDirection: ObjectOrFunction;\n    directions?: string[];\n  }) => {\n    const nextDirections = options.directions || CubeTexture.format.coord_s;\n\n    for (let direction of nextDirections) {\n      const asset = await parseAssetCallback(\n        direction,\n        options.assetForDirection\n      );\n      const texture = await loadAsync(asset);\n      this.images.push(texture);\n    }\n    this.needsUpdate = true;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}