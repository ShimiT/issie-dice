{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport THREE from \"./Three\";\nexport function alignMesh(mesh) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 0.5,\n    y: 0.5,\n    z: 0.5\n  };\n  var nAxis = axis || {};\n  var box = new THREE.Box3().setFromObject(mesh);\n  var size = new THREE.Vector3();\n  box.getSize(size);\n  var min = {\n    x: -box.min.x,\n    y: -box.min.y,\n    z: -box.min.z\n  };\n  for (var key of Object.keys(nAxis)) {\n    var scale = nAxis[key];\n    mesh.position[key] = min[key] - size[key] + size[key] * scale;\n  }\n}\nexport function scaleLongestSideToSize(mesh, size) {\n  var sizedVector = new THREE.Vector3();\n  new THREE.Box3().setFromObject(mesh).getSize(sizedVector);\n  var width = sizedVector.x,\n    height = sizedVector.y,\n    depth = sizedVector.z;\n  var longest = Math.max(width, Math.max(height, depth));\n  var scale = size / longest;\n  mesh.scale.set(scale, scale, scale);\n}\nexport function computeMeshNormals(mesh) {\n  mesh.traverse(function () {\n    var _ref = _asyncToGenerator(function* (child) {\n      if (child instanceof THREE.Mesh) {\n        child.geometry.mergeVertices();\n        child.geometry.computeVertexNormals();\n        child.geometry.computeFaceNormals();\n      }\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK;AAEZ,OAAM,SAAU,SAAS,CAAC,IAAgB,EAAmC;EAAA,IAAjC,IAAI,uEAAG;IAAE,CAAC,EAAE,GAAG;IAAE,CAAC,EAAE,GAAG;IAAE,CAAC,EAAE;EAAG,CAAE;EAC3E,IAAM,KAAK,GAAG,IAAI,IAAI,CAAA,CAAE;EACxB,IAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC;EAEhD,IAAI,IAAI,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE;EAC9B,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC;EACjB,IAAM,GAAG,GAAG;IAAE,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAAE,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAAE,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC;EAAC,CAAE;EAE3D,KAAK,IAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;IACpC,IAAM,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC;IACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK;EAC9D;AACH;AAEA,OAAM,SAAU,sBAAsB,CAAC,IAAgB,EAAE,IAAY,EAAA;EACnE,IAAI,WAAW,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE;EACrC,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC;EAEzD,IAAW,KAAK,GAA0B,WAAW,CAA7C,CAAC;IAAY,MAAM,GAAe,WAAW,CAAnC,CAAC;IAAa,KAAK,GAAK,WAAW,CAAxB,CAAC;EAE9B,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;EACxD,IAAM,KAAK,GAAG,IAAI,GAAG,OAAO;EAC5B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;AACrC;AAGA,OAAM,SAAU,kBAAkB,CAAC,IAAgB,EAAA;EACjD,IAAI,CAAC,QAAQ;IAAA,6BAAC,WAAO,KAAU,EAAI;MACjC,IAAI,KAAK,YAAY,KAAK,CAAC,IAAI,EAAE;QAE/B,KAAK,CAAC,QAAQ,CAAC,aAAa,EAAE;QAC9B,KAAK,CAAC,QAAQ,CAAC,oBAAoB,EAAE;QACrC,KAAK,CAAC,QAAQ,CAAC,kBAAkB,EAAE;MACpC;IACH,CAAC;IAAA;MAAA;IAAA;EAAA,IAAC;AACJ","sourcesContent":["import THREE from './Three';\n\nexport function alignMesh(mesh: THREE.Mesh, axis = { x: 0.5, y: 0.5, z: 0.5 }) {\n  const nAxis = axis || {};\n  const box = new THREE.Box3().setFromObject(mesh);\n\n  let size = new THREE.Vector3();\n  box.getSize(size);\n  const min = { x: -box.min.x, y: -box.min.y, z: -box.min.z };\n\n  for (const key of Object.keys(nAxis)) {\n    const scale = nAxis[key];\n    mesh.position[key] = min[key] - size[key] + size[key] * scale;\n  }\n}\n\nexport function scaleLongestSideToSize(mesh: THREE.Mesh, size: number) {\n  let sizedVector = new THREE.Vector3();\n  new THREE.Box3().setFromObject(mesh).getSize(sizedVector);\n\n  const { x: width, y: height, z: depth } = sizedVector;\n\n  const longest = Math.max(width, Math.max(height, depth));\n  const scale = size / longest;\n  mesh.scale.set(scale, scale, scale);\n}\n\n/** Used for smoothing imported meshes */\nexport function computeMeshNormals(mesh: THREE.Mesh) {\n  mesh.traverse(async (child: any) => {\n    if (child instanceof THREE.Mesh) {\n      /// Smooth geometry\n      child.geometry.mergeVertices();\n      child.geometry.computeVertexNormals();\n      child.geometry.computeFaceNormals();\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}